#!/usr/bin/env python3
"""
Generate client.pyi stub file from COMMANDS dictionary.

This script automatically generates type stubs for the Client and AsyncClient classes
based on the command functions defined in the COMMANDS dictionary. This ensures that
IDE autocompletion and type checking stay in sync with available commands.

Usage:
    python scripts/generate_client_stubs.py
"""

import sys
import inspect
from pathlib import Path
from typing import get_type_hints

# Add src to path
repo_root = Path(__file__).parent.parent
sys.path.insert(0, str(repo_root / "src"))

from pypixelcolor.commands import COMMANDS


def format_type_annotation(annotation) -> str:
    """Format a type annotation to a string.
    
    Args:
        annotation: The type annotation
        
    Returns:
        Formatted type string
    """
    if annotation == inspect.Parameter.empty:
        return ""
    
    # Handle type objects
    if isinstance(annotation, type):
        return annotation.__name__
    
    # Convert to string and clean it up
    type_str = str(annotation)
    
    # Remove <class '...'> wrapper
    if type_str.startswith("<class '") and type_str.endswith("'>"):
        type_str = type_str[8:-2]
    
    # Handle typing module types
    type_str = type_str.replace("typing.", "")
    
    return type_str


def get_function_signature(func) -> tuple[str, str]:
    """Extract function signature and return type annotation.
    
    Args:
        func: The function to inspect
        
    Returns:
        Tuple of (parameters_string, return_type)
    """
    sig = inspect.signature(func)
    params = []
    
    for param_name, param in sig.parameters.items():
        # Build parameter string with type hints and defaults
        param_str = param_name
        
        # Add type annotation if available
        if param.annotation != inspect.Parameter.empty:
            type_str = format_type_annotation(param.annotation)
            if type_str:
                param_str += f": {type_str}"
        
        # Add default value if available
        if param.default != inspect.Parameter.empty:
            if isinstance(param.default, str):
                param_str += f' = "{param.default}"'
            elif param.default is None:
                param_str += " = None"
            elif isinstance(param.default, bool):
                param_str += f" = {param.default}"
            else:
                param_str += f" = {param.default}"
        
        params.append(param_str)
    
    params_str = ", ".join(params)
    return_type = "None"
    
    return params_str, return_type


def format_docstring(doc: str | None, indent: int = 8) -> str:
    """Format a docstring with proper indentation.
    
    Args:
        doc: The docstring to format
        indent: Number of spaces to indent
        
    Returns:
        Formatted docstring or empty string
    """
    if not doc:
        return ""
    
    # Get first line of docstring (brief description)
    first_line = doc.strip().split('\n')[0]
    indent_str = " " * indent
    return f'\n{indent_str}"""' + first_line + '"""'


def generate_method_stub(method_name: str, func, is_async: bool = True) -> str:
    """Generate a method stub for the .pyi file.
    
    Args:
        method_name: Name of the method
        func: The command function
        is_async: Whether this is an async method
        
    Returns:
        The method stub as a string
    """
    params_str, return_type = get_function_signature(func)
    doc = format_docstring(func.__doc__)
    
    async_keyword = "async " if is_async else ""
    
    # Add 'self' parameter
    if params_str:
        params_str = f"self, {params_str}"
    else:
        params_str = "self"
    
    stub = f"    {async_keyword}def {method_name}({params_str}) -> {return_type}:{doc}\n        ...\n"
    return stub


def generate_pyi_file() -> str:
    """Generate the complete client.pyi file content.
    
    Returns:
        The complete .pyi file content as a string
    """
    header = '''"""Type stubs for client module to enable IDE autocomplete.

This file is auto-generated by scripts/generate_client_stubs.py
DO NOT EDIT MANUALLY - your changes will be overwritten.
"""

from typing import Union
import pathlib

class AsyncClient:
    """Asynchronous client for controlling the LED matrix via BLE."""
    
    def __init__(self, address: str) -> None: ...
    
    async def connect(self) -> None:
        """Connect to the BLE device."""
        ...
    
    async def disconnect(self) -> None:
        """Disconnect from the BLE device."""
        ...
    
'''
    
    # Generate method stubs for all commands
    method_stubs = []
    for cmd_name, cmd_func in sorted(COMMANDS.items()):
        stub = generate_method_stub(cmd_name, cmd_func, is_async=True)
        method_stubs.append(stub)
    
    # Add context manager methods
    context_methods = '''    async def __aenter__(self) -> AsyncClient: ...
    async def __aexit__(self, exc_type, exc_val, exc_tb) -> None: ...


'''
    
    # Now generate Client class (synchronous wrapper)
    client_header = '''class Client:
    """Synchronous client for controlling the LED matrix via BLE."""
    
    def __init__(self, address: str) -> None: ...
    
    def connect(self) -> None:
        """Connect to the BLE device."""
        ...
    
    def disconnect(self) -> None:
        """Disconnect from the BLE device."""
        ...
    
'''
    
    # Generate synchronous versions of all command methods
    sync_method_stubs = []
    for cmd_name, cmd_func in sorted(COMMANDS.items()):
        stub = generate_method_stub(cmd_name, cmd_func, is_async=False)
        sync_method_stubs.append(stub)
    
    # Add context manager methods for Client
    sync_context_methods = '''    def __enter__(self) -> Client: ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> None: ...
'''
    
    # Combine everything
    pyi_content = (
        header +
        "".join(method_stubs) +
        context_methods +
        client_header +
        "".join(sync_method_stubs) +
        sync_context_methods
    )
    
    return pyi_content


def main():
    """Main entry point."""
    print("ðŸ”§ Generating client.pyi from COMMANDS dictionary...")
    
    # Generate the content
    pyi_content = generate_pyi_file()
    
    # Write to file
    output_path = repo_root / "src" / "pypixelcolor" / "client.pyi"
    output_path.write_text(pyi_content, encoding="utf-8")
    
    print(f"âœ… Generated {output_path}")
    print(f"ðŸ“Š Added {len(COMMANDS)} command methods")
    print(f"ðŸ“„ Total lines: {len(pyi_content.splitlines())}")
    
    # Show which commands were added
    print("\nðŸ“‹ Commands included:")
    for cmd_name in sorted(COMMANDS.keys()):
        print(f"   - {cmd_name}")
    
    print("\nðŸŽ‰ Done! The client.pyi file has been updated.")


if __name__ == "__main__":
    main()
